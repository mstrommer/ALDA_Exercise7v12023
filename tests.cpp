// Test definitions. Do NOT edit this file!

#include <tuple>

//#define CATCH_CONFIG_MAIN // defines main() automatically
#include "lib/catch.hpp"
#include "astar.hpp"

// =====================
// Graph Testcases
// ---------------------

// Possible values in the graph:
// -1 ... Blocked / NO NODE / Barricade / Wall...
//  0 ... Node - initial value
// >0 ... Actual cost from source to this very node
// -2 ... Shortest Path
// INFINITE ... each Node, except for the source node, is set to INFINITE in the beginning of A*

TEST_CASE("Test1", "checkPath1")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0, 0, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int notExpected[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0, 0, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {7,8};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing if there are values set within the graph.");
    getResult(graph);
    REQUIRE(memcmp(graph, notExpected, sizeof(graph)) != 0);
}

TEST_CASE("Test2", "checkSourceTarget")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0, 0, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {7,8};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing if source and target are marked on the path.");
    getResult(graph);
    REQUIRE(graph[1][1] == -2); // source
    REQUIRE(graph[7][8] == -2); // target
}

TEST_CASE("Test3", "edgeCase")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0, 0, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {7,8};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing if the shortest path was found. Use main to find the problem and print the graph using g_print().");
    getResult(graph);
    REQUIRE(graph[7][3] == -2); // these fields must be crossed for the shortest path
    REQUIRE(graph[8][3] == -2);
    REQUIRE(graph[8][4] == -2);
    REQUIRE(graph[8][5] == -2);
}

TEST_CASE("Test4", "maze")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0,-1, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0,-1, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0,-1, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {7,8};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing if a path through a maze is found. Use the main function and g_print() to find any problems.");
    getResult(graph);
    REQUIRE(graph[1][1] == -2);
    REQUIRE(graph[1][2] == -2);
    REQUIRE(graph[1][3] == -2);
    REQUIRE(graph[1][4] == -2);
    REQUIRE(graph[1][8] == -2);
    REQUIRE(graph[2][8] == -2);
    REQUIRE(graph[3][8] == -2);
    REQUIRE(graph[4][8] == -2);
    REQUIRE(graph[5][8] == -2);
    REQUIRE(graph[6][8] == -2);
    REQUIRE(graph[7][8] == -2);
}

TEST_CASE("Test5", "alternateGraph")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {5,5};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing an alternate graph. Use the main function and g_print() to find any problems.");
    getResult(graph);
    REQUIRE(graph[1][1] == -2);
    REQUIRE(graph[1][2] == -2);
    REQUIRE(graph[1][3] == -2);
    REQUIRE(graph[1][4] == -2);
    REQUIRE(graph[5][5] == -2);

}

TEST_CASE("Test6", "checkHeuristic")
{
    int graph[ROWS][COLS] = {
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0,-1, 0,-1},
        {-1, 0, 0,-1, 0, 0, 0,-1, 0,-1},
        {-1, 0, 0,-1,-1,-1,-1,-1, 0,-1},
        {-1, 0, 0, 0, 0,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0,-1,-1, 0, 0, 0,-1},
        {-1,-1,-1, 0,-1,-1, 0, 0, 0,-1},
        {-1, 0, 0, 0, 0, 0, 0, 0, 0,-1},
        {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
    };
    int start[2] = {1,1};
    int end[2] = {7,8};
    g_init(graph);
    g_astar(start, end);
    INFO("Testing if a heuristic was used or not. Use main to find the problem and print the graph using g_print().");
    getResult(graph);
    REQUIRE(graph[6][8] == INFINITE); // if a heuristic is used the following nodes must not be visited
    REQUIRE(graph[5][8] == INFINITE);
    REQUIRE(graph[4][8] == INFINITE);
    REQUIRE(graph[3][8] == INFINITE);
    REQUIRE(graph[8][1] == INFINITE);
}
